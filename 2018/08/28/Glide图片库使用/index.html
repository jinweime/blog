<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Glide图片库使用 | 金威的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.Glide是什么？Glide是Google在2014的IO大会发布一款图片处理框架，是目前android领域比较成熟的一款，也是Google官方推荐的图片处理框架，主要支持网络图片、二进制流、drawable资源、本地图片显示，还支持本地视频显示。 2.Glide基本功能使用 在app级别下面配置gradle  1">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide图片库使用">
<meta property="og:url" content="http://github.com/jinweime/blog.git/2018/08/28/Glide图片库使用/index.html">
<meta property="og:site_name" content="金威的博客">
<meta property="og:description" content="1.Glide是什么？Glide是Google在2014的IO大会发布一款图片处理框架，是目前android领域比较成熟的一款，也是Google官方推荐的图片处理框架，主要支持网络图片、二进制流、drawable资源、本地图片显示，还支持本地视频显示。 2.Glide基本功能使用 在app级别下面配置gradle  123dependencies &amp;#123;    compile &amp;apos;c">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1930388-a568192ad29bf2c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-28T07:54:17.721Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide图片库使用">
<meta name="twitter:description" content="1.Glide是什么？Glide是Google在2014的IO大会发布一款图片处理框架，是目前android领域比较成熟的一款，也是Google官方推荐的图片处理框架，主要支持网络图片、二进制流、drawable资源、本地图片显示，还支持本地视频显示。 2.Glide基本功能使用 在app级别下面配置gradle  123dependencies &amp;#123;    compile &amp;apos;c">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1930388-a568192ad29bf2c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/blog/css/typing.css">
  
  <link rel="stylesheet" href="/blog/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-Glide图片库使用" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/blog/">Home</a>
    
      <a class="main-nav-link" href="/blog/archives">Archives</a>
    
      <a class="main-nav-link" href="/blog/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Glide图片库使用
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h3 id="1-Glide是什么？"><a href="#1-Glide是什么？" class="headerlink" title="1.Glide是什么？"></a>1.Glide是什么？</h3><p>Glide是Google在2014的IO大会发布一款图片处理框架，是目前android领域比较成熟的一款，也是Google官方推荐的图片处理框架，主要支持网络图片、二进制流、drawable资源、本地图片显示，还支持本地视频显示。</p>
<h3 id="2-Glide基本功能使用"><a href="#2-Glide基本功能使用" class="headerlink" title="2.Glide基本功能使用"></a>2.Glide基本功能使用</h3><ol>
<li>在app级别下面配置gradle</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.github.bumptech.glide:glide:3.7.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用起来<br>通过Glide类进行一个链式调用，下面代码显示了一张网络图片。</li>
</ol>
<ul>
<li><p>with支持传入一下对象，我们在使用过程中尽量要传入activity、fragment因为glide会依赖它们的生命周期，如果onPaush时候，Glide就会暂停加载，重新onResume之后，又会继续加载。<br><img src="http://upload-images.jianshu.io/upload_images/1930388-a568192ad29bf2c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
</li>
<li><p>load() 支持网络图片、二进制流、drawable资源、本地图片的传入。</p>
</li>
<li><p>crossFade  这是开启显示淡入淡出的动画</p>
</li>
<li><p>override 如果获取的网络图片过大，我们通过它进行一个大小的裁剪，传入width和height参数进行宽高裁剪。</p>
</li>
<li><p>diskCacheStrategy 磁盘缓存的设置，默认Glide会开启的。</p>
</li>
</ul>
<p>DiskCacheStrategy.NONE 什么都不缓存<br>DiskCacheStrategy.SOURCE 只缓存全尺寸图<br>DiskCacheStrategy.RESULT 只缓存最终的加载图<br>DiskCacheStrategy.ALL 缓存所有版本图（默认行为）</p>
<blockquote>
<p>Glide 不仅缓存了全尺寸的图，还会根据 ImageView 大小所生成的图也会缓存起来。比如，请求一个 800x600 的图加载到一个 400x300 的 ImageView 中，Glide默认会将这原图还有加载到 ImageView 中的 400x300 的图也会缓存起来。</p>
</blockquote>
<ul>
<li>error 这里的设置是当加载图片出现错误时，显示的图片。</li>
<li>placeholder 图片加载完成之前显示的占位图。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">String url = &quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2912495429,3557331556&amp;fm=27&amp;gp=0.jpg&quot;;</span><br><span class="line">       Glide</span><br><span class="line">               .with(this)</span><br><span class="line">               .load(url)</span><br><span class="line">               .crossFade()</span><br><span class="line">               .override(200, 200)</span><br><span class="line">               .diskCacheStrategy(DiskCacheStrategy.ALL)</span><br><span class="line">               .error(R.mipmap.active_user_default_icon)</span><br><span class="line">               .placeholder(R.mipmap.ic_album_image_source_pick)</span><br><span class="line">               .into(img);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>获取Glide请求完成的Bitmap</strong><br>通过前面这种方式我们能很轻松的显示一张，图片到ImgeView上。但是我们有时候想获取加载完成后的Bitmap怎么办呢，可以通过SimpleTarget来获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//SimpleTarget 获取bitmap,定义siez</span><br><span class="line">    SimpleTarget&lt;Bitmap&gt; mSimpleTarget = new SimpleTarget&lt;Bitmap&gt;(200, 200) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123;</span><br><span class="line">            img.setImageBitmap(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> //获取Bitmap的加载方法。</span><br><span class="line">        Glide.with(getApplicationContext())</span><br><span class="line">                .load(url)</span><br><span class="line">                .asBitmap()</span><br><span class="line">                .into(mSimpleTarget);</span><br></pre></td></tr></table></figure>
<p>我们定义了一个SimpleTarget类，里面有一个onResourceReady方法的回调，会返回加载完成的Bitmap对象，into传入这个SimpleTarget对象。</p>
<p><strong>自定义控件使用Glide显示Image</strong><br>有时候我们自定义的控件也需要显示Imaeg,但是这个控件不是Image类或者子类，那么前面这种方法就会不使用了，我们可以通过ViewTarget来实现这个逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyImageView extends FrameLayout &#123;</span><br><span class="line">    private ImageView mImageView;</span><br><span class="line"></span><br><span class="line">    public MyImageView(@NonNull Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyImageView(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyImageView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onFinishInflate() &#123;</span><br><span class="line">        super.onFinishInflate();</span><br><span class="line">        mImageView = new ImageView(getContext());</span><br><span class="line">        addView(mImageView, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImage(Drawable drawable) &#123;</span><br><span class="line">        mImageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyImageView img3;</span><br><span class="line">//ViewTarget自定义View也支持获取Bitmap</span><br><span class="line">       ViewTarget viewTarget = new ViewTarget&lt;MyImageView, GlideDrawable&gt;(img3) &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123;</span><br><span class="line">               img3.setImage(resource);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Glide.with(getApplicationContext())</span><br><span class="line">               .load(url)</span><br><span class="line">               .into(viewTarget);</span><br></pre></td></tr></table></figure>
<p>通过定义一个ViewTarget传入了二个泛型类，一个是MyImageView，一个是GlideDrawable,传入了img3。通过onResourceReady的回调我们可以对自定义控件进行图片显示了。</p>
<h3 id="3-Glide原理了解"><a href="#3-Glide原理了解" class="headerlink" title="3.Glide原理了解?"></a>3.Glide原理了解?</h3><p>Glide的with、load、into虽然只有三个方法调用但是内部的逻辑是很复杂的，成吨的代码这里我只做一个大概了解。首先with方法会构造一个单例的RequestManager对象。</p>
<p><strong>with方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">       RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">       return retriever.get(activity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManagerRetriever get() &#123;</span><br><span class="line">      return INSTANCE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来我们一个程序生命周期内只有一个RequestManager对象，工程师在设计的时候很考虑到性能的问题。</p>
<p><strong>load方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public DrawableTypeRequest&lt;String&gt; load(String string) &#123;</span><br><span class="line">       return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接着通过RequestManage对象的load方法返回一个DrawableTypeRequest类，它是一个DrawableRequestBuilder的一个子类，通过类名可以看出来主要作用是主要是构建请求中的一些参数用的，比如我们之前写的 override、error、placeholder、diskCacheStrategy这些辅助方法的设置。</p>
<p><strong>into方法</strong><br>最后的一个方法也是最复杂的一个，是真正请求网络请求的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;GlideDrawable&gt; into(ImageView view) &#123;</span><br><span class="line">        return super.into(view);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">       Util.assertMainThread();</span><br><span class="line">      ...</span><br><span class="line">       return into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">   public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) &#123;</span><br><span class="line">       if (GlideDrawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">           return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view);</span><br><span class="line">       &#125; else if (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">           return (Target&lt;Z&gt;) new BitmapImageViewTarget(view);</span><br><span class="line">       &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">           return (Target&lt;Z&gt;) new DrawableImageViewTarget(view);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Unhandled class: &quot; + clazz</span><br><span class="line">                   + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>into接收一个ViewTeger，</p>
<p>into的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123;</span><br><span class="line">     ...</span><br><span class="line">       Request request = buildRequest(target);</span><br><span class="line">       target.setRequest(request);</span><br><span class="line">       lifecycle.addListener(target);</span><br><span class="line">       requestTracker.runRequest(request);</span><br><span class="line"></span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void runRequest(Request request) &#123;</span><br><span class="line">       requests.add(request);</span><br><span class="line">       if (!isPaused) &#123;</span><br><span class="line">           request.begin();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           pendingRequests.add(request);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>runRequest方法来控制请求的队列，如果当前视图状态是Paused状态就会把request添加到等待请求的队列，如果不是则直接执行。里面会有一个HttpUrlFetcher来执行前面封装好的网络请求</p>
<h3 id="4-Glide是如何缓存的？"><a href="#4-Glide是如何缓存的？" class="headerlink" title="4.Glide是如何缓存的？"></a>4.Glide是如何缓存的？</h3><p>glide缓存主要分为</p>
<ol>
<li>内存缓存<blockquote>
<p>内存缓存主要是防止同样的图片重复读取到内存中来，解约JVM的内存空间</p>
</blockquote>
</li>
</ol>
<p>glide的内存缓存机制是使用LruCache算法实现，首先需要会需要一个key，这个key是通过url+构建请求时候的参数决定的。keyFactory.buildKey的代码就是生成Key的逻辑。glide内存缓存会调用二个方法来获取缓存。</p>
<ul>
<li><p>loadFromCache<br>使用LruCache</p>
</li>
<li><p>loadFromActiveResources<br>使用弱引用</p>
</li>
</ul>
<p>内存缓存的逻辑就是，先会在loadFromCache中去取缓存，这个是一个LruCaChe算啊实现的，如果取到了值就会把它存入一个弱引用中。这样的防止被LruCache算法回收掉，如果LruCache没有取到就会去loadFromActiveResources方法里面取。 </p>
<p>如果都没有那就会开启子线程去网络请求图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,</span><br><span class="line">           DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span><br><span class="line">           Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123;</span><br><span class="line">       Util.assertMainThread();</span><br><span class="line">       long startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">       final String id = fetcher.getId();</span><br><span class="line">       EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class="line">               loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class="line">               transcoder, loadProvider.getSourceEncoder());</span><br><span class="line"></span><br><span class="line">       EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">       if (cached != null) &#123;</span><br><span class="line">           cb.onResourceReady(cached);</span><br><span class="line">           if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">               logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">       if (active != null) &#123;</span><br><span class="line">           cb.onResourceReady(active);</span><br><span class="line">           if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">               logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EngineJob current = jobs.get(key);</span><br><span class="line">       if (current != null) &#123;</span><br><span class="line">           current.addCallback(cb);</span><br><span class="line">           if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">               logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">           &#125;</span><br><span class="line">           return new LoadStatus(cb, current);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">       DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">               transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">       EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">       jobs.put(key, engineJob);</span><br><span class="line">       engineJob.addCallback(cb);</span><br><span class="line">       engineJob.start(runnable);</span><br><span class="line"></span><br><span class="line">       if (Log.isLoggable(TG, Log.VERBOSE)) &#123;</span><br><span class="line">           logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">       &#125;</span><br><span class="line">       return new LoadStatus(cb, engineJob);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>磁盘缓存</li>
</ol>
<blockquote>
<p>磁盘缓存主要是防止同一张网络图片，重复从网络中读取和下载，磁盘缓存也是使用LruCache算法实现的。</p>
</blockquote>
<p>磁盘缓存有一个逻辑，当需要去加载一张图片的时候，Glide默认不会显示原始图片，而是会对图片进行压缩转换。经过这些转换操作之后才会把，图片显示出来，磁盘缓存默认就是缓存转换后的图片。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/blog/2018/08/28/Glide图片库使用/" class="article-date">
  <time datetime="2018-08-28T07:51:16.000Z" itemprop="datePublished">2018-08-28</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/blog/2018/08/28/Kotlin新概念/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Kotlin新概念
        
      </div>
    </a>
  
  
    <a href="/blog/2018/08/02/Java类的加载机制/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java类的加载机制</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="archives"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/jinweime"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.instagram.com/jinweicom/"><span class="fa fa-instagram"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
