<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>volley源码分析 | 金威的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.HTTP协议了解http是一种应用层的协议，底层通过TCP来进行可靠的数据传输。HTTP是基于TCP的应用层协议，它在更高的层次封装了TCP的使用细节，使网络请求更加易用，TCP连接是因特网基于流的一种可靠连接，它为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送过">
<meta property="og:type" content="article">
<meta property="og:title" content="volley源码分析">
<meta property="og:url" content="http://github.com/jinweime/blog.git/2018/01/21/volley源码分析/index.html">
<meta property="og:site_name" content="金威的博客">
<meta property="og:description" content="1.HTTP协议了解http是一种应用层的协议，底层通过TCP来进行可靠的数据传输。HTTP是基于TCP的应用层协议，它在更高的层次封装了TCP的使用细节，使网络请求更加易用，TCP连接是因特网基于流的一种可靠连接，它为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送过来。  HTTP的7种请求方式GETPOSTDELETEPUTHEADTRACE">
<meta property="og:image" content="http://or66xwp90.bkt.clouddn.com/11.png">
<meta property="og:image" content="http://or66xwp90.bkt.clouddn.com/22.png">
<meta property="og:image" content="http://or66xwp90.bkt.clouddn.com/QQ20171213-190709@2x.png">
<meta property="og:image" content="http://or66xwp90.bkt.clouddn.com/volley-request%202.png">
<meta property="og:updated_time" content="2018-01-28T10:28:26.756Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="volley源码分析">
<meta name="twitter:description" content="1.HTTP协议了解http是一种应用层的协议，底层通过TCP来进行可靠的数据传输。HTTP是基于TCP的应用层协议，它在更高的层次封装了TCP的使用细节，使网络请求更加易用，TCP连接是因特网基于流的一种可靠连接，它为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送过来。  HTTP的7种请求方式GETPOSTDELETEPUTHEADTRACE">
<meta name="twitter:image" content="http://or66xwp90.bkt.clouddn.com/11.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/blog/css/typing.css">
  
  <link rel="stylesheet" href="/blog/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-volley源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/blog/">Home</a>
    
      <a class="main-nav-link" href="/blog/archives">Archives</a>
    
      <a class="main-nav-link" href="/blog/about">About</a>
    
      <a class="main-nav-link" href="/blog/Link">Link</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      volley源码分析
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h4 id="1-HTTP协议了解"><a href="#1-HTTP协议了解" class="headerlink" title="1.HTTP协议了解"></a>1.HTTP协议了解</h4><p>http是一种应用层的协议，底层通过TCP来进行可靠的数据传输。HTTP是基于TCP的应用层协议，它在更高的层次封装了TCP的使用细节，使网络请求更加易用，TCP连接是因特网基于流的一种可靠连接，它为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送过来。</p>
<ul>
<li>HTTP的7种请求方式<br>GET<br>POST<br>DELETE<br>PUT<br>HEAD<br>TRACE<br>POTIONS</li>
</ul>
<p><img src="http://or66xwp90.bkt.clouddn.com/11.png" alt=""><br><strong>HTTP报文格式解析</strong><br>不同的请求方式，它们的请求格式也是不一样的，请求格式也就是报文格式。 通常来说一个HTTP请求报文由 请求行(request line)、请求头部(head)、空行、请求数据 4个部分组成。</p>
<p><img src="http://or66xwp90.bkt.clouddn.com/22.png" alt=""></p>
<ol>
<li>请求行<br>报文的第一行就是请求行，这一行说明了这段报文以什么方式请求，包含了HTTP的版本号等一些协议信息。</li>
<li>请求头部<br>请求头部是以 key:value的形式来说明请求数据的，这里面说明了请求服务器的一些host，content-tye，Encoding的一些说明。</li>
<li>请求数据<br>POST请求的方式才会有请求数据，如果请求是以POST提交过来，那么这里面就会有post的请求数据，可以文本形式或者二进制数据根据你请求post提交的数据类型决定。</li>
</ol>
<p><strong>GET 请求报文格式</strong></p>
<blockquote>
<p>www.jinweime.com?id=2<br>这个是一个典型的get请求，get请求的参数会跟在url后面。问号后面作为第一个参数，以&amp;进行参数拼接。</p>
</blockquote>
<p>http请求协议如下</p>
<blockquote>
<p>GET /?id=2 HTTP/1.1<br>Host: jinweime.com<br>Cache-Control: no-cache</p>
</blockquote>
<p>可以看到第一行为请求行，请求方式为GET，子路径是?id=2 代表参数id的值为2，HTTP版本为1.1。 后面二行是head区域，第一个请求头是主机地址，第三行也是一个head。GET方式的请求参数都是附加的URL中所以请求数据部分为空。</p>
<p><strong>POST请求报文格式</strong></p>
<blockquote>
<p>POST /api/feed. HTTP/1.1<br>Accept-Encoding: gzip<br>Content-Length: 225873<br>Content-Ttpe: multipart/form-data; boundary=Ocxx3329f….<br>Host: www.myhost.com<br>Connection: Keep-Alive</p>
<p>–OCxxqFJE…<br>Content-Dispotition: form-data; name==”username”<br>Content-Type: text/plain; charset=UTF-8<br>Content-Transfer-Encoding: 8bit</p>
<p>MrSimple<br>–Cxxii32F..<br>Content-Dispotition: form-data; name==”title”<br>Content-Type: text/plain; charset=UTF-8<br>Content-Transfer-Encoding: 8bit</p>
<p>TEST<br>–Ffsaxx……–</p>
</blockquote>
<p>这串报代表向 www.myhost.com/api/feed/这个地址发送了一个POST请求。 请求的数据格式为 Content-Type： multipart.form-data，报文有二个参数 username title，username的值为MrSimple。title的值为TEST。  最后一行是结束行以 –  boundary值 –  结束， 如果格式不正确服务器将会解析不到的你请求。</p>
<p><strong>响应报文</strong><br>HTTP响应报文也是由三个部分组成，分别是：状态行   消息head   响应报文，和请求报文的格式十分相似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;状态行&gt;</span><br><span class="line">&lt;响应报文 head&gt;</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;响应报文内容&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到和请求报文相比，只是把第一行的请求行换成了状态行了，状态行提供一个状态码来说明此次请求的资源情况。</p>
<blockquote>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
</blockquote>
<p>其中的HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器响应请求的状态码；Reason-Phrase表示状态码的文本描述。状态码是一个三位的数字，第一个数字定义了响应的类别。</p>
<p><strong>常见的状态码</strong></p>
<ul>
<li>200 OK；客户端请求成功</li>
<li>400 Bad Request:客户端请求有语法错误，服务器不能正确的解析</li>
<li>401 Unauthorized；请求未授权</li>
<li>403 Forbidden; 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found; 请求的资源不存在， 比如输入了错误的地址；</li>
<li>500 Internal Server Error; 服务器发生了错误</li>
<li>503 Server Unavailable； 服务器当前不能处理客户端请求</li>
</ul>
<p><strong>常见的请求头部</strong></p>
<ul>
<li>Content-Type: 请求数据的格式</li>
<li>Content-Length; 消息的长度</li>
<li>Host: 请求主机名</li>
<li>User-Agent; 发出请求的浏览器类型，可以自定义</li>
<li>Accept: 客户端可识别的内容类型</li>
<li>Accept-Encoding: 客户端可识别的数据编码</li>
<li>Connection: 允许客户端和服务器指定请求/响应连接有关的选项，比如设置Keep-Alive 表示保持连接</li>
</ul>
<h4 id="Android中执行网络请求"><a href="#Android中执行网络请求" class="headerlink" title="Android中执行网络请求"></a>Android中执行网络请求</h4><blockquote>
<p>android中提供了二种执行网络请求的方式，一种使用 Apache的HttpClient，另一种Java提供的 HttpUrlConnection。这二种方法都提供了完整的 API, 都很很好的实现对网络的请求功能，但是某些情况下我们需要做取舍分清楚二种方式的区别。</p>
</blockquote>
<ul>
<li><p>HttpClient<br>android SDK自带了 Apache的HttpClient，它提供了对HTTP协议的全面支持，可以使用HttpClient来执行 HTTP GET和HTTP POST请求。</p>
</li>
<li><p>HttpUrlConnection</p>
</li>
</ul>
<blockquote>
<p>最佳选择HttpUrlConnection。二者对比来说，在android 2.2版本之前，HttpClient有较少的一些BUG，而HttpURLConnection一直存在一些让厌烦的BUG，比如在对一个可读的InputStream 调用colse()方法时，就有可能导致连接池失败。因此在 android 2.2版本之前使用 HttpClient是比较好的选择。 但是在 android2.3及之后 HttpUrlConnect有了进一步的更新， 它api 简单，体积小，因此非常适用于 Android项目中。 HttpUrlConnection的压缩和缓存机制可以有效的减少网络访问的流量，这块在提升手机省电和流量方面也起来很多的作用。另外在Android 6.0中，HttpClient以及被移除了，所以以后开发中HttpUrlConnection是我们唯一的选择了。</p>
</blockquote>
<p><strong>使用HttpUrlConnection请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">fun sendHttpClient(url: String) &#123;</span><br><span class="line">        val url = URL(url)</span><br><span class="line">        var conn = url.openConnection() as HttpURLConnection</span><br><span class="line">        //读取时时间为 2s</span><br><span class="line">        conn.readTimeout = 2000</span><br><span class="line">        //请求超时时间为 5s</span><br><span class="line">        conn.connectTimeout = 5000</span><br><span class="line">        //设置请求方式</span><br><span class="line">        conn.requestMethod = &quot;POST&quot;</span><br><span class="line">        //接收输入流</span><br><span class="line">        conn.doInput = true</span><br><span class="line">        //启动输出流，需要传递参数时需要开启</span><br><span class="line">        conn.doInput = true</span><br><span class="line">        //添加 Header</span><br><span class="line">        conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">        //添加请求参数</span><br><span class="line">        var paramsList = ArrayList&lt;NameValuePair&gt;()</span><br><span class="line">        paramsList.add(BasicNameValuePair(&quot;username&quot;, &quot;jinwei&quot;))</span><br><span class="line">        paramsList.add(BasicNameValuePair(&quot;pwd&quot;, &quot;pwd.com&quot;))</span><br><span class="line">        writeParams(conn.outputStream, paramsList)</span><br><span class="line">        //发起请求</span><br><span class="line">        conn.connect()</span><br><span class="line">        var input = conn.inputStream</span><br><span class="line">        //获取结果</span><br><span class="line">        var str = convertStreamToString(input)</span><br><span class="line">        Log.i(TAG, &quot;Request Data: &quot; + str)</span><br><span class="line">        input.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun writeParams(outpit: OutputStream, paramsList: List&lt;NameValuePair&gt;) &#123;</span><br><span class="line">        val paramStr = StringBuffer()</span><br><span class="line">        for (value in paramsList) &#123;</span><br><span class="line">            if (!TextUtils.isEmpty(paramStr)) &#123;</span><br><span class="line">                paramStr.append(&quot;&amp;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            paramStr.append(URLEncoder.encode(value.name, &quot;UTF-8&quot;))</span><br><span class="line">            paramStr.append(&quot;=&quot;)</span><br><span class="line">            paramStr.append(URLEncoder.encode(value.value, &quot;UTF-8&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">        var writer = BufferedWriter(OutputStreamWriter(outpit, &quot;UTF-8&quot;))</span><br><span class="line">        //写入参数写入输入流</span><br><span class="line">        Log.i(TAG, paramStr.toString())</span><br><span class="line">        writer.write(paramStr.toString())</span><br><span class="line">        writer.flush()</span><br><span class="line">        writer.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun convertStreamToString(input: InputStream): String &#123;</span><br><span class="line">        var buffer = BufferedReader(InputStreamReader(input))</span><br><span class="line">        var sb = StringBuffer()</span><br><span class="line">        var line: String</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                line = buffer.readLine()</span><br><span class="line">                if (!TextUtils.isEmpty(line)) &#123;</span><br><span class="line">                    sb.append(line + &quot;\n&quot;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Volley使用"><a href="#2-Volley使用" class="headerlink" title="2. Volley使用"></a>2. Volley使用</h3><p><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/google/volley">github</a></p>
<p><a href="https://www.youtube.com/watch?v=yhv8l9F44qo" target="_blank" rel="noopener">VIDEO介绍</a><br><img src="http://or66xwp90.bkt.clouddn.com/QQ20171213-190709@2x.png" alt="安静"></p>
<p>volley的架构图</p>
<p><img src="http://or66xwp90.bkt.clouddn.com/volley-request%202.png" alt="架构图"></p>
<blockquote>
<p>volley是2013年 google I/O大会上推出的一款网络请求相关的框架</p>
</blockquote>
<p>它有以下好处</p>
<ul>
<li>网络请求的自动调度。</li>
<li>多个并发网络连接。</li>
<li>具有标准HTTP缓存一致性的透明磁盘和内存响应缓存。</li>
<li>支持请求优先级。</li>
<li>取消请求api。可以取消单个请求，也可以设置要取消的请求的块或范围。</li>
<li>自定义重试</li>
</ul>
<p>缺点</p>
<ul>
<li>不适合数据量过大的传输操作</li>
</ul>
<p><strong>构建一个stringRequest</strong></p>
<p>一般来说我们一个应用启动后只需要全局获取一个<br>Volley.newRequestQueue(this)实例就够了，这样可以有效的节省系统资源的消耗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun sendStringRequest() &#123;</span><br><span class="line">       var request = Volley.newRequestQueue(this)</span><br><span class="line">       var url = &quot;http://baidu.com&quot;</span><br><span class="line">       var strrequest = StringRequest(Request.Method.GET, url,</span><br><span class="line">               object : Response.Listener&lt;String&gt; &#123;</span><br><span class="line">                   override fun onResponse(response: String?) &#123;</span><br><span class="line">                       Log.i(TAG, response)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               object : Response.ErrorListener &#123;</span><br><span class="line">                   override fun onErrorResponse(error: VolleyError?) &#123;</span><br><span class="line">                       Log.i(TAG, &quot;error&quot;)</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;)</span><br><span class="line">       request.add(strrequest)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>很简单成功的打印了返回的Html数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">                                                           &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</span><br><span class="line">                                                            &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>JsonRequest</strong></p>
<p>这里我们用的JsonRequest的子类JsonObjectRequest来构建了一个请求，它支持JSON格式的Request和Response。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun sendJsonRequest() &#123;</span><br><span class="line">        var request = Volley.newRequestQueue(this)</span><br><span class="line">        var url = &quot;http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=关键字&amp;bk_length=600&quot;</span><br><span class="line">        var strrequest = JsonObjectRequest(Request.Method.POST, url, null,</span><br><span class="line">                object : Response.Listener&lt;JSONObject&gt; &#123;</span><br><span class="line">                    override fun onResponse(response: JSONObject?) &#123;</span><br><span class="line">                        Log.i(TAG, response.toString())</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                object : Response.ErrorListener &#123;</span><br><span class="line">                    override fun onErrorResponse(error: VolleyError?) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;error&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">        request.add(strrequest)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>成功的返回了一串JSON格式的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:390935,&quot;subLemmaId&quot;:390935,&quot;newLemmaId&quot;:7105697,&quot;key&quot;.......</span><br></pre></td></tr></table></figure></p>
<p><strong>ImageRequest</strong></p>
<p>Volley还支持对图片的获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun sendImageRequest() &#123;</span><br><span class="line">        var request = Volley.newRequestQueue(this)</span><br><span class="line">        var url = &quot;http://img.my.csdn.net/uploads/201603/26/1458988468_5804.jpg&quot;</span><br><span class="line">        var strrequest = ImageRequest(url,</span><br><span class="line">                object : Response.Listener&lt;Bitmap&gt; &#123;</span><br><span class="line">                    override fun onResponse(response: Bitmap?) &#123;</span><br><span class="line">                        findViewById&lt;ImageView&gt;(R.id.imageView).setImageBitmap(response)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;, 511, 511, Bitmap.Config.ARGB_8888,</span><br><span class="line">                object : Response.ErrorListener &#123;</span><br><span class="line">                    override fun onErrorResponse(error: VolleyError?) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;error&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">        request.add(strrequest)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码成功的Bitmap显示到了ImageView上面</p>
<h3 id="3-Volley源码分析"><a href="#3-Volley源码分析" class="headerlink" title="3. Volley源码分析"></a>3. Volley源码分析</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var request = Volley.newRequestQueue(this)</span><br></pre></td></tr></table></figure>
<p>最终会到newRequestQueue方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123;</span><br><span class="line">        BasicNetwork network;</span><br><span class="line">        if (stack == null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class="line">                network = new BasicNetwork(new HurlStack());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</span><br><span class="line">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class="line">                // At some point in the future we&apos;ll move our minSdkVersion past Froyo and can</span><br><span class="line">                // delete this fallback (along with all Apache HTTP code).</span><br><span class="line">                String userAgent = &quot;volley/0&quot;;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String packageName = context.getPackageName();</span><br><span class="line">                    PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class="line">                    userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class="line">                &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                network = new BasicNetwork(</span><br><span class="line">                        new HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            network = new BasicNetwork(stack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return newRequestQueue(context, network);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码进入到Build.VERSION.SDK_INT &gt;= 9的逻辑，network = new BasicNetwork(new HurlStack());创建了一个network对象，我们重点关系HrlStack（）这个对象，这个对象是最终执行网络请求的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    public HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">            throws IOException, AuthFailureError &#123;</span><br><span class="line">        String url = request.getUrl();</span><br><span class="line">//        Log.i(&quot;jinwei&quot;,&quot; ## executeRequest =  &quot;+url);</span><br><span class="line">        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.putAll(request.getHeaders());</span><br><span class="line">        map.putAll(additionalHeaders);</span><br><span class="line">        if (mUrlRewriter != null) &#123;</span><br><span class="line">            String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">            if (rewritten == null) &#123;</span><br><span class="line">                throw new IOException(&quot;URL blocked by rewriter: &quot; + url);</span><br><span class="line">            &#125;</span><br><span class="line">            url = rewritten;</span><br><span class="line">        &#125;</span><br><span class="line">        URL parsedUrl = new URL(url);</span><br><span class="line">        HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">        for (String headerName : map.keySet()) &#123;</span><br><span class="line">            connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">        &#125;</span><br><span class="line">        setConnectionParametersForRequest(connection, request);</span><br><span class="line">        // Initialize HttpResponse with data from the HttpURLConnection.</span><br><span class="line">        int responseCode = connection.getResponseCode();</span><br><span class="line">        if (responseCode == -1) &#123;</span><br><span class="line">            // -1 is returned by getResponseCode() if the response code could not be retrieved.</span><br><span class="line">            // Signal to the caller that something was wrong with the connection.</span><br><span class="line">            throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!hasResponseBody(request.getMethod(), responseCode)) &#123;</span><br><span class="line">            return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()),</span><br><span class="line">                connection.getContentLength(), inputStreamFromConnection(connection));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看到执行网络请求使用的HttpURLConnection处理的，具体的调用过程我们继续分析。</p>
<p>newRequestQueue方法最好执行到了return newRequestQueue(context, network);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static RequestQueue newRequestQueue(Context context, Network network) &#123;</span><br><span class="line">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里执行了queue.start()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">        stop();  // Make sure any currently running dispatchers are stopped.</span><br><span class="line">        // Create the cache dispatcher and start it.</span><br><span class="line">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">        mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        // Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class="line">        Log.i(&quot;jinwei&quot;,&quot; ## mDispatchers.length ## &quot; +mDispatchers.length);</span><br><span class="line">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                    mCache, mDelivery);</span><br><span class="line">            mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里总共开启了5个 Thread，一个CacheThread和四个NetWorkThread。</p>
<p>NetWorkThread的run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Log.i(&quot;jinwei&quot;,&quot; ## run ##&quot;);</span><br><span class="line">                processRequest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // We may have been interrupted because it was time to quit.</span><br><span class="line">                Log.i(&quot;jinwei&quot;,&quot; ## mQuit ##&quot;);</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个while循环，内部有一个PriorityBlockingQueue队列take数据，如果返回为Null线程就会挂起等待新的队列进来。</p>
<p><strong>重点方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void processRequest() throws InterruptedException &#123;</span><br><span class="line">       long startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">       // Take a request from the queue.</span><br><span class="line">       Request&lt;?&gt; request = mQueue.take();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">           // If the request was cancelled already, do not perform the</span><br><span class="line">           // network request.</span><br><span class="line">           if (request.isCanceled()) &#123;</span><br><span class="line">               request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">               request.notifyListenerResponseNotUsable();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">           // Perform the network request.</span><br><span class="line">           NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">           request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line"></span><br><span class="line">           // If the server returned 304 AND we delivered a response already,</span><br><span class="line">           // we&apos;re done -- don&apos;t deliver a second identical response.</span><br><span class="line">           if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">               request.finish(&quot;not-modified&quot;);</span><br><span class="line">               request.notifyListenerResponseNotUsable();</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Parse the response here on the worker thread.</span><br><span class="line">           Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">           request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line"></span><br><span class="line">           // Write to cache if applicable.</span><br><span class="line">           // TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class="line">           if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class="line">               mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">               request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Post the response back.</span><br><span class="line">           request.markDelivered();</span><br><span class="line">           mDelivery.postResponse(request, response);</span><br><span class="line">           request.notifyListenerResponseReceived(response);</span><br><span class="line">       &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">           volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">           parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">           request.notifyListenerResponseNotUsable();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class="line">           VolleyError volleyError = new VolleyError(e);</span><br><span class="line">           volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">           mDelivery.postError(request, volleyError);</span><br><span class="line">           request.notifyListenerResponseNotUsable();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Request&lt;?&gt; request = mQueue.take()取出之前request.add(strrequest)的数据，如果没有则会一直挂起。</p>
<p>执行这里就会执行到之前HurlStack类中的executeRequest方法来通过HttpUrlConnection来构建一个网络请求了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request)</span><br></pre></td></tr></table></figure>
<p>源码的简单分析就到这了，具体的设计思路和实现还需要深入研究了。</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/blog/2018/01/21/volley源码分析/" class="article-date">
  <time datetime="2018-01-21T15:11:20.000Z" itemprop="datePublished">2018-01-21</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/blog/2018/01/22/单例模式花样玩法/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          单例模式花样玩法
        
      </div>
    </a>
  
  
    <a href="/blog/2018/01/11/android8-0自动缩小字体特性/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">android8.0自动缩小字体特性</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="archives"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/jinweime"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.instagram.com/jinweicom/"><span class="fa fa-instagram"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
