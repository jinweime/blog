<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>http | 金威的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="http到底是什么？ 定义它是一种网络传输协议，位于TCP/IP协议族的最顶层应用层。  HTTPHypertext Transfer Protocol（超文本传输协议）和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。 http工作">
<meta property="og:type" content="article">
<meta property="og:title" content="http">
<meta property="og:url" content="http://github.com/jinweime/blog.git/2019/04/15/http/index.html">
<meta property="og:site_name" content="金威的博客">
<meta property="og:description" content="http到底是什么？ 定义它是一种网络传输协议，位于TCP/IP协议族的最顶层应用层。  HTTPHypertext Transfer Protocol（超文本传输协议）和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。 http工作模型 浏览器    用户在浏览器输入地址回车访问 浏览器拼装请求报文发送给服务器">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1930388-d2463d934b88d7e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1930388-9c865ebf8a2f64e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1g25fhmon6wj31580fqt8s.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g24jjjdkw9j30og0b4dfu.jpg">
<meta property="og:updated_time" content="2019-04-17T02:56:18.256Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="http">
<meta name="twitter:description" content="http到底是什么？ 定义它是一种网络传输协议，位于TCP/IP协议族的最顶层应用层。  HTTPHypertext Transfer Protocol（超文本传输协议）和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。 http工作模型 浏览器    用户在浏览器输入地址回车访问 浏览器拼装请求报文发送给服务器">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1930388-d2463d934b88d7e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/blog/css/typing.css">
  
  <link rel="stylesheet" href="/blog/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/blog/">Home</a>
    
      <a class="main-nav-link" href="/blog/archives">Archives</a>
    
      <a class="main-nav-link" href="/blog/about">About</a>
    
      <a class="main-nav-link" href="/blog/Link">Link</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      http
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h4 id="http到底是什么？"><a href="#http到底是什么？" class="headerlink" title="http到底是什么？"></a>http到底是什么？</h4><ul>
<li><p>定义<br>它是一种网络传输协议，位于TCP/IP协议族的最顶层应用层。</p>
</li>
<li><p>HTTP<br>Hypertext Transfer Protocol（超文本传输协议）和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。</p>
<h4 id="http工作模型"><a href="#http工作模型" class="headerlink" title="http工作模型"></a>http工作模型</h4></li>
<li><p>浏览器</p>
</li>
</ul>
<ol>
<li>用户在浏览器输入地址回车访问</li>
<li>浏览器拼装请求报文发送给服务器</li>
<li>服务器接受处理请求发送响应报文给浏览器</li>
<li>浏览器解析响应报文并使用渲染引擎显示</li>
</ol>
<ul>
<li>手机APP</li>
</ul>
<ol>
<li>用户触发一个网络请求</li>
<li>应用拼装HTTP报文请求发送给服务器</li>
<li>服务器接受报文请求解析处理返回响应报文</li>
<li>应用解析响应报文获取响应数据显示到手机界面</li>
</ol>
<h4 id="请求报文格式"><a href="#请求报文格式" class="headerlink" title="请求报文格式"></a>请求报文格式</h4><p>示例</p>
<blockquote>
<p><a href="https://jack.com/users/?gender=male" target="_blank" rel="noopener">https://jack.com/users/?gender=male</a></p>
</blockquote>
<ul>
<li>https 协议类型</li>
<li>jack.com 服务器地址</li>
<li>users/?gender=male 路径path</li>
</ul>
<hr>
<p><strong>如图报文格式</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1930388-d2463d934b88d7e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>请求行：Method（GET POST PUT DELETE…）、Path、HTTP version</li>
<li>Headers:请求的meta data，Meta Data就是元数据也就是数据中的数据。</li>
<li>Body:要发送给服务器的内容，这个Body只有当时Post等类型请求情况下才会有body。</li>
</ul>
<h4 id="Method类型"><a href="#Method类型" class="headerlink" title="Method类型"></a>Method类型</h4><ul>
<li><strong>GET</strong><br>幂等一次操作和多次操作的结果是一样的<br>取资源、对服务器数据不修改、不发送body<blockquote>
<p>GET /users/1 HTTP/1.1<br>Host: api.github.com</p>
</blockquote>
</li>
<li><p><strong>POST</strong><br>主要用于增加或者修改资源、发送给服务器的内容写在body里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br><span class="line">name=jack&amp;gender=male</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PUT</strong><br>主要用于修改资源、发送给服务器内容写在body里面</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /users/1 HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 13</span><br><span class="line">gender=female</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>DELETE</strong><br>幂等，一次和多次删除都是一样的。<br>主要用于删除资源、不发送 Body</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /users/1 HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>HEAD</strong></li>
</ul>
<p>幂等</p>
<p><em>和 GET 使用方法完全相同唯一区别在于，返回的响应中没有 Body<br>可以用于做一些获取信息的操作比如断点续传，先head一下获取信息来判断是否需要做下一次请求；</em></p>
<h3 id="Status-Code"><a href="#Status-Code" class="headerlink" title="Status Code"></a>Status Code</h3><ul>
<li>1xx：临时性消息。如：100 （继续发送）、101（正在切换协议）</li>
<li>2xx：成功。最典型的是 200（OK）、201（创建成功）。</li>
<li>3xx：重定向。如 301（永久移动）、302（暂时移动）、304（内容未改变）。</li>
<li>4xx：客户端错误。如 400（客户端请求错误）、401（认证失败）、403（被禁⽌止）、404（找不不到内容）。</li>
<li>5xx：服务器器错误。如 500（服务器器内部错误）</li>
</ul>
<ul>
<li><strong>Headers</strong><br><em>http消息的元数据(matedata)数据的数据</em></li>
<li>Host<br>目标主机，不是在网络上用于寻址的，而是在目标服务器器上用于定位子服务器的。</li>
</ul>
<ol>
<li>在报文拼装发送之前通过DNS寻址找到目标服务器</li>
<li>在host拼装在报文里面找到目标服务器</li>
</ol>
<p>这种方式主要是用来处理一个服务器可能会有多个虚拟服务器，如果通过host可以精确的定位需要访问的服务器。</p>
<ul>
<li>Content-Type/Content-Length<br><em>body的类型和长度这个在Http中还是比较重要，因为客户端和服务器在进行数据传输的时候经常要约定一些数据格式的类型，不同Content-Type对应的报文拼装方式也是不一样的</em></li>
</ul>
<ol>
<li>text/html<br>请求 Web 页面是返回响应的类型，Body 中返回 html 文本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 853</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">..............................</span><br></pre></td></tr></table></figure>
<ol>
<li>x-www-form-urlencoded<br>Web 页面纯文本表单的提交方式,如果是存文本的话可以使用这种encoded。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: api.github.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 27</span><br><span class="line">name=rengwuxian&amp;gender=male</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.multitype/form-data<br>Web 页面含有二进制文件时的提交方式，推荐使用带文件的表单也可以上传文本的表单但是会比较消耗带宽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: multipart/form-data;boundary=</span><br><span class="line">----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Length: 2382</span><br><span class="line">&gt;------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line">jack</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;avatar.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">JFIFHHvOwX9jximQrWa......</span><br></pre></td></tr></table></figure></p>
<ol>
<li>application/json , image/jpeg , application/zip …<br>单项内容（文本或非文本都可以），用于 Web Api 的响应或者 POST / PUT 的请求，优点就是格式灵活格式自由。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;name&quot;:&quot;jack&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span><br><span class="line">Location</span><br><span class="line">User-Agent</span><br><span class="line">Range/Accpet-Range</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p><strong>Transfer: chunked (分块传输编码 Chunked Transfer Encoding)</strong><br>这种情况一般用于服务器暂时无法返回全部的信息，但是也不能让客户端一直等着所以可以分段传输一些资源给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type：text/html</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">chun</span><br><span class="line">9</span><br><span class="line">ked trans</span><br><span class="line">12</span><br><span class="line">fer encoding</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Location</strong><br>指定重定向的⽬目标 URL,比如访问一个<a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 如果这个网站支持的是<a href="https://xxx.com，那么这个location值就是带Https的这站点，浏览器自动就做了一个这样的定向转发。" target="_blank" rel="noopener">https://xxx.com，那么这个location值就是带Https的这站点，浏览器自动就做了一个这样的定向转发。</a></p>
</li>
<li><strong>User-Agent</strong><br>用户代理理，即是谁实际发送请求、接受响应的，例例如手机浏览器器、某款手机 App。这个参数的来源是为了支持早期的火狐浏览器，由于之前有很多浏览器没有统一兼容性导致很多网站，只能在某一部分的浏览器达到很好的效果。很多网站需要做很多浏览器的适配，后面网站只去做火狐浏览器的兼容，所以这个User-Agent就全部写成了Mozilla，一直到现在一来都是大部分都是Mozilla这值。</li>
</ul>
<p>这个值还可以用于手机端的适配，我们访问同一个网站在手机端和浏览器可能访问的效果都是不一样的，手机上显示的页面可能会不一样，这种都可以通过这个代理类型来区别如何进行适配。</p>
<ul>
<li><strong>Range / Accept-Range</strong><br>指定Body的内容范围，一般用于分段取内容。</li>
</ul>
<ul>
<li><p><strong>REST</strong><br>网络上众说纷纷，个人觉得就是一种架构风格，一种规范设计最早是从HTTP开始。</p>
</li>
<li><p>Server-Client architecture<br>C/S架构我给你发一个请求，你给我返回一个请求HTTP本身就是符合这种架构设计的。</p>
</li>
<li>StateLessness<br>无状态就是前后之前没有任何关联，比如要获取一个用户信息但是没有登录，服务器肯定会告知客户端请先登录，http本身就是符合这种设计的。</li>
<li>Cacheability<br>可缓存，http本身就是可以缓存的不管是机器还是节点，整个架构都是符合这个规范，和软件本身是没什么关系的。</li>
<li>Layered System<br>系统分层意思就是客户端不管访问的是一个机器，还是一个集群，总之要保证我的访问是没问题的。这个规范HTTP也是必然的，不然达到这个要求那么软件也就是没法做了。</li>
<li><p>Code on demand<br>服务器在返回的信息里面，可以返回一些可以执行代码的。比如javascript，打开一些网页里面会有一些可以执行的代码。</p>
</li>
<li><p><strong>RESTful HTTP</strong><br>就是正确的使用HTTP，比如规定用GET就是用GET，用POST就用POST。</p>
</li>
</ul>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li>古代密码棒<br><img src="http://upload-images.jianshu.io/upload_images/1930388-9c865ebf8a2f64e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>古代最早的密码学就是这样的，为了防止信息的泄露这里有二个东西，不同规格的木棒(密钥），布带（密文）。通过这二个东西就是实现信息的加密了，只有在指定规格的木棒上面缠布带才能得到对应的信息。</li>
</ul>
<h3 id="替换式密码"><a href="#替换式密码" class="headerlink" title="替换式密码"></a>替换式密码</h3><p>最简单就体现就是在原始字符上面对每个字母进行+1，加完之后的字符就是密文了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始字符：ABCDEFFEJ  (对每个字符进行+1)</span><br><span class="line">加密后字符：BCDEFGGFO</span><br><span class="line">解密原始字符：ABCDEFFEJ  (对每个字符进行-1)</span><br></pre></td></tr></table></figure>
<p>解密在通过在密文上对每个字符进行一次-1得到就是我们的原文</p>
<h4 id="现代加密"><a href="#现代加密" class="headerlink" title="现代加密"></a>现代加密</h4><p>现代的加密方式由于有了计算机所以它支持复杂度更大，运算量更大的加密逻辑，但是它和核心原理其实也是和这种加密棒的原理很像。</p>
<ul>
<li>对称加密<br>比木棒更加复杂的加密算法，通信双方使用同一个密钥。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g25fhmon6wj31580fqt8s.jpg" alt=""></p>
<ol>
<li><p>DES<br>56位密钥，密钥太短被弃用了，因为有可能被穷举法破解就是我们说的暴力破解，就是一个一个的试。</p>
</li>
<li><p>AES<br>128位，192位，256位，主流的加密。<br>被暴力破解的可能性很低，时间太久。</p>
</li>
<li><p>缺点<br>密钥不能安全的在网络上传输，如果泄露加密的信息就会被破解。</p>
</li>
</ol>
<p><strong>关于破解</strong><br>任何一种加密其实都没有被破解不了的一说，知识被破解的几率太小太小，比如我们如果通过穷举法去破解，它花上的时间可能要上千年这种时间点就不现实了。</p>
<blockquote>
<p>为什么需要非对称加密，如果你的密钥需要在网络上传输，如何把密钥要安全的给到，这个安全传输本身就是一个难题。非对称加密可以解决这个问题，因为它是把公钥公开出来的，密钥只能自己持有。传输公开的都是公钥这样就解决了公钥需要传输的加密场景，非对称加密更加复杂它的加密原理和进制数据的溢出有关。</p>
</blockquote>
<ul>
<li>非对称加密</li>
</ul>
<ol>
<li>RSA</li>
</ol>
<p>A通过B的公钥来加密原文，发送给B B得到密文之后使用自己的私钥进行一次解密，这样就可以得到原文。非对称加密中加密的密钥叫做公钥，解密密钥的叫做私钥，公钥是可以公开的谁需要发送信息给我都可以拿到此密钥进行加密发送，但是私钥是绝对不可以公开的只有是自己持有。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g24jjjdkw9j30og0b4dfu.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/blog/2019/04/15/http/" class="article-date">
  <time datetime="2019-04-15T04:19:56.000Z" itemprop="datePublished">2019-04-15</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/blog/2018/10/12/复杂度分析/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">复杂度分析</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="archives"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/jinweime"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.instagram.com/jinweicom/"><span class="fa fa-instagram"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
